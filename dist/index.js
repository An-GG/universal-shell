import{spawn as h,execSync as O}from"child_process";import{warn as P}from"@tsmodule/log";import{translateForPlatform as L}from"./platform.js";const T=process.platform==="linux"||process.platform==="darwin",i=process.platform==="win32",x={stdio:"pipe",shell:!0,detached:!i,env:process.env},g={log:!0,silent:!1,commandTranslations:{},shellTranslations:{},...x},D=({log:u=!0,silent:p=!1,commandTranslations:d={},shellTranslations:S={},...w}=g)=>{let r=null;return{childProcess:r,async run(t){if(r)throw new Error("Only one command per shell.");if(typeof t=="object"){let s=process.platform;t.posix&&T&&(s="posix");const e=t[s];if(!e)throw new Error("No command found for platform: "+JSON.stringify({platform:process.platform,command:t}));t=e}const{cmd:a,args:f}=L(t,S,d);return!p&&u&&P(`$ ${a} ${f.join(" ")}`,["dim"],{preLines:1,postLines:1}),await new Promise((s,e)=>{r=h(a,f,w);let c="",m="";if(!r)throw new Error("Child process was not set.");const l=o=>{r=null;const n={code:o,stdout:c.trim(),stderr:m.trim()};o===0||o===1&&!i?s(n):e(n)};r.stdout?.on("data",o=>{c+=o.toString()}),r.stderr?.on("data",o=>{m+=o.toString()}),r.on("close",l),r.on("exit",l),r.on("error",l),p||(r.stdout?.pipe(process.stdout),r.stderr?.pipe(process.stderr))})},kill(t="SIGKILL"){if(r?.pid)if(i)O(`taskkill /t /f /pid ${r.pid}`);else return process.kill(-r.pid,t);return!0}}};export*from"./types.js";export{D as createShell};
